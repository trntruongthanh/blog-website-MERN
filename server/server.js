/*
  bcrypt: Hash password ƒë·ªÉ b·∫£o m·∫≠t.
  nanoid: T·∫°o username ng·∫´u nhi√™n n·∫øu c·∫ßn.
  jsonwebtoken: T·∫°o token JWT ƒë·ªÉ x√°c th·ª±c.


  const server = express(); t·∫°o ra m·ªôt server Express ƒë·ªÉ:  Qu·∫£n l√Ω middleware.
  X·ª≠ l√Ω API routes.
  Nh·∫≠n request, g·ª≠i response.
  Ch·∫°y ·ª©ng d·ª•ng web b·∫±ng server.listen(PORT).


  autoIndex: true ‚ûù T·ª± ƒë·ªông t·∫°o index trong MongoDB (ch·ªâ d√πng trong development).
  autoIndex: false ‚ûù Kh√¥ng t·ª± ƒë·ªông t·∫°o index (d√πng trong production).
  Production n√™n t·∫°o index th·ªß c√¥ng ƒë·ªÉ `kh√¥ng ·∫£nh h∆∞·ªüng hi·ªáu su·∫•t.
  üöÄ Khi ph√°t tri·ªÉn:
  ‚úî D√πng autoIndex: true.

  üåç Khi deploy production:
  ‚úî D√πng autoIndex: false + ch·∫°y User.syncIndexes().
*/

/*
  T·∫°o m·ªôt instance c·ªßa Express ƒë·ªÉ qu·∫£n l√Ω API.
  C·ªïng c·ªßa server l·∫•y t·ª´ bi·∫øn m√¥i tr∆∞·ªùng ho·∫∑c m·∫∑c ƒë·ªãnh l√† 5000.

  6-20 k√Ω t·ª±.
  √çt nh·∫•t 1 s·ªë (\d).
  √çt nh·∫•t 1 ch·ªØ th∆∞·ªùng ([a-z]).
  √çt nh·∫•t 1 ch·ªØ hoa ([A-Z]).


  D√πng async/await ƒë·ªÉ k·∫øt n·ªëi MongoDB.
  autoIndex:
  true trong development (t·ª± ƒë·ªông t·∫°o index).
  false trong production (tr√°nh ·∫£nh h∆∞·ªüng hi·ªáu su·∫•t, c·∫ßn ch·∫°y User.syncIndexes() th·ªß c√¥ng).
  N·∫øu l·ªói, log error v√† d·ª´ng server (process.exit(1)).

  H√†nh ƒë·ªông	C·∫ßn token kh√¥ng?
üë§ Li√™n quan ƒë·∫øn c√° nh√¢n	‚úÖ C√≥
üåç C√¥ng khai, ai c≈©ng xem ƒë∆∞·ª£c	‚ùå Kh√¥ng
üìù T·∫°o / s·ª≠a / x√≥a d·ªØ li·ªáu	‚úÖ C√≥
üîç Ch·ªâ xem, kh√¥ng c√° nh√¢n h√≥a	‚ùå Kh√¥ng
*/

import "dotenv/config";

import express from "express";
import cors from "cors";
import bcrypt from "bcrypt";
import jwt from "jsonwebtoken";

import { nanoid } from "nanoid";

import mongoose from "mongoose";
import admin from "firebase-admin";
import { getAuth } from "firebase-admin/auth";
import { v2 as cloudinary } from "cloudinary";

import User from "./Schema/User.js";
import Blog from "./Schema/Blog.js";

import { readFileSync } from "fs";

const serviceAccount = JSON.parse(
  readFileSync(process.env.FIREBASE_SERVICE_ACCOUNT_PATH, "utf-8")
);

const server = express();
const PORT = process.env.PORT || 5000;

//==============================================================================================

cloudinary.config({
  cloud_name: process.env.CLOUDINARY_NAME,
  api_key: process.env.CLOUDINARY_API_KEY,
  api_secret: process.env.CLOUDINARY_API_SECRET_KEY,
});

admin.initializeApp({
  credential: admin.credential.cert(serviceAccount),
});

//============================================================================================

let emailRegex = /^\w+([\.-]?\w+)*@\w+([\.-]?\w+)*(\.\w{2,3})+$/;
let passwordRegex = /^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).{6,20}$/;

const isProduction = process.env.NODE_ENV === "production";

server.use(express.json()); // B·∫Øt bu·ªôc ƒë·ªÉ ƒë·ªçc JSON t·ª´ request body (middleware)
server.use(cors());

//============================================================================================
(async () => {
  try {
    await mongoose.connect(process.env.MONGO_BLOG_URL, {
      autoIndex: !isProduction,
    });
    console.log("Connected to MongoDB ‚úÖ");
  } catch (error) {
    // N·∫øu c·∫ßn t·ª± ƒë·ªông k·∫øt n·ªëi l·∫°i, c√≥ th·ªÉ th√™m c∆° ch·∫ø retry ·ªü ƒë√¢y
    setTimeout(() => {
      console.log("Retrying MongoDB connection...");
      mongoose
        .connect(process.env.MONGO_BLOG_URL, {
          autoIndex: !isProduction,
        })
        .catch((err) => console.error("MongoDB retry failed:", err));
    }, 5000);
  }
})();

//===============================================================================================

const generateUploadURL = () => {
  const date = new Date();
  const imageName = `${nanoid()}-${date.getTime()}.jpeg`;

  const timestamp = Math.round(date.getTime() / 1000);
  const paramsToSign = { timestamp, public_id: imageName };

  const signature = cloudinary.utils.api_sign_request(
    paramsToSign,
    process.env.CLOUDINARY_API_SECRET_KEY
  );

  return {
    url: `https://api.cloudinary.com/v1_1/${process.env.CLOUDINARY_NAME}/image/upload`,
    timestamp,
    signature,
    api_key: process.env.CLOUDINARY_API_KEY,
    public_id: imageName,
  };
};

//==============================================================================================

const formatDataSend = (user) => {
  const access_token = jwt.sign(
    { id: user._id },
    process.env.SECRET_ACCESS_KEY
  );

  return {
    access_token,
    profile_img: user.personal_info.profile_img,
    username: user.personal_info.username,
    fullname: user.personal_info.fullname,
  };
};

const generateUsername = async (email) => {
  // if (!email.includes("@")) throw new Error("Invalid email format");

  let username = email.split("@")[0];

  if (await User.exists({ "personal_info.username": username })) {
    username += nanoid().substring(0, 5);
  }
  return username;
};

//======================================================================================================

/* b·∫£o v·ªá c√°c route ri√™ng t∆∞ (protected routes)
  next() l√† m·ªôt h√†m callback c√≥ s·∫µn trong middleware. Khi b·∫°n g·ªçi n√≥, Express s·∫Ω:
  Chuy·ªÉn sang middleware ti·∫øp theo trong chu·ªói ho·∫∑c
  Chuy·ªÉn ƒë·∫øn route x·ª≠ l√Ω cu·ªëi c√πng (n∆°i b·∫°n g·ª≠i response).
*/
const verifyJWT = (req, res, next) => {
  const authHeader = req.headers["authorization"];

  const token = authHeader && authHeader.split(" ")[1];

  if (!token) {
    return res.status(401).json({ error: "No access token" });
  }

  jwt.verify(token, process.env.SECRET_ACCESS_KEY, (err, user) => {
    if (err) {
      return res.status(403).json({ error: "Access token is invalid" });
    }

    req.user = user.id;

    next();
  });
};

//=====================================================================================

/*
  .toLowerCase() gi√∫p ƒë·ªìng b·ªô URL (chu·∫©n SEO).
  /[^a-z0-9]+/g: lo·∫°i b·ªè k√Ω t·ª± ƒë·∫∑c bi·ªát, gi·ªØ l·∫°i ch·ªØ th∆∞·ªùng & s·ªë.
  .replace(/^-+|-+$/g, ""): xo√° d·∫•u - d∆∞ ·ªü hai ƒë·∫ßu.
  nanoid() th√™m ph·∫ßn ng·∫´u nhi√™n ƒë·ªÉ tr√°nh tr√πng slug 
*/
const slugify = (title) => {
  const slug = title
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, "-")
    .replace(/^-+|-+$/g, "");

  return `${slug}-${nanoid()}`;
};

//===========================================================================================================
/*
  Trong Express.js, req.body ch·ª©a d·ªØ li·ªáu t·ª´ request m√† client g·ª≠i l√™n server, th∆∞·ªùng l√† d·ªØ li·ªáu JSON t·ª´ body c·ªßa HTTP request.
  üìå M√£ h√≥a m·∫≠t kh·∫©u b·∫±ng bcrypt
  Hash (BƒÉm) l√† qu√° tr√¨nh bi·∫øn ƒë·ªïi d·ªØ li·ªáu ƒë·∫ßu v√†o th√†nh m·ªôt chu·ªói c·ªë ƒë·ªãnh, kh√¥ng th·ªÉ kh√¥i ph·ª•c l·∫°i gi√° tr·ªã g·ªëc.
  Hash kh√¥ng th·ªÉ ƒë·∫£o ng∆∞·ª£c: Kh√¥ng th·ªÉ l·∫•y m·∫≠t kh·∫©u g·ªëc t·ª´ chu·ªói hash.
  Trong b·∫£o m·∫≠t, hashing ƒë∆∞·ª£c d√πng ƒë·ªÉ l∆∞u m·∫≠t kh·∫©u thay v√¨ l∆∞u plaintext (m·∫≠t kh·∫©u th√¥).
  N·∫øu hacker l·∫•y ƒë∆∞·ª£c database, h·ªç c≈©ng kh√¥ng bi·∫øt m·∫≠t kh·∫©u th·∫≠t c·ªßa ng∆∞·ªùi d√πng.
  
  password: M·∫≠t kh·∫©u ng∆∞·ªùi d√πng nh·∫≠p v√†o.
  10: Salt Rounds ‚Äì s·ªë v√≤ng x·ª≠ l√Ω b·ªï sung ƒë·ªÉ tƒÉng ƒë·ªô ph·ª©c t·∫°p (c√†ng cao c√†ng b·∫£o m·∫≠t, nh∆∞ng c≈©ng l√†m ch·∫≠m qu√° tr√¨nh).
  L∆∞u √Ω: M·ªói l·∫ßn hash, k·∫øt qu·∫£ s·∫Ω kh√°c nhau do bcrypt s·ª≠ d·ª•ng salt ƒë·ªÉ ngƒÉn ch·∫∑n t·∫•n c√¥ng t·ª´ ƒëi·ªÉn.
  
*/

server.post("/signup", async (req, res) => {
  try {
    let { fullname, email, password } = req.body;

    //üìå validating the data from frontend
    if (fullname.length < 3) {
      return res
        .status(403)
        .json({ error: "Fullname must be at least 3 letters long." });
    }

    if (!email.length || !emailRegex.test(email)) {
      return res.status(403).json({ error: "Email is invalid" });
    }

    if (!passwordRegex.test(password)) {
      return res.status(403).json({
        error:
          "Password should be 6 to 20 characters long with a numeric, 1 lowercase and 1 uppercase letter.",
      });
    }

    const hashed_password = await bcrypt.hash(password, 10);

    const username = await generateUsername(email);

    const user = new User({
      personal_info: {
        fullname,
        email,
        password: hashed_password,
        username,
      },
    });

    // üìå L∆∞u user v√†o database
    const savedUser = await user.save();

    return res.status(200).json(formatDataSend(savedUser));
  } catch (err) {
    // üìå Ki·ªÉm tra l·ªói tr√πng email
    if (err.code === 11000) {
      return res.status(500).json({ error: "Email already exists" });
    }
    console.error("Error in /signup:", err);

    return res.status(500).json({ error: "Internal server error" });
  }
});

// ==============================================================================================
server.post("/signin", async (req, res) => {
  const { email, password } = req.body;

  try {
    const user = await User.findOne({ "personal_info.email": email });

    if (!user) {
      return res.status(403).json({ error: "Email not found" });
    }

    if (!user.google_auth) {
      const isMatch = await bcrypt.compare(
        password,
        user.personal_info.password
      );

      if (!isMatch) {
        return res.status(403).json({ error: "Incorrect password." });
      }

      return res.status(200).json(formatDataSend(user));
    } else {
      return res.status(403).json({
        error: "Account was created using Google. Try logging in with Google.",
      });
    }
  } catch (error) {
    console.error("Error in /signin:", error.message);
    return res.status(500).json({ error: "Internal server error" });
  }
});

// ====================================================================================
/**
getAuth():
L·∫•y module x√°c th·ª±c (auth) c·ªßa Firebase Admin SDK.
ƒêi·ªÅu n√†y gi√∫p s·ª≠ d·ª•ng c√°c ch·ª©c nƒÉng x√°c th·ª±c c·ªßa Firebase tr√™n server.

.verifyIdToken(access_token):
X√°c minh token ID (access_token) m√† client g·ª≠i l√™n.

·∫¢nh ƒë·∫°i di·ªán (picture) ƒë∆∞·ª£c ƒë·ªïi k√≠ch th∆∞·ªõc t·ª´ "s96-c" ‚Üí "s384-c" (ch·∫•t l∆∞·ª£ng cao h∆°n).
*/
server.post("/google-auth", async (req, res) => {
  try {
    let { access_token } = req.body;

    if (!access_token) {
      return res.status(400).json({ error: "Missing access_token" });
    }

    // X√°c minh v√† gi·∫£i m√£ token Google
    const decodedUser = await getAuth().verifyIdToken(access_token);

    // Tr√≠ch xu·∫•t th√¥ng tin t·ª´ token
    let { email, name, picture } = decodedUser;
    picture = picture.replace("s96-c", "s384-c");

    // Ki·ªÉm tra xem user ƒë√£ t·ªìn t·∫°i trong database hay ch∆∞a
    let user;

    try {
      user = await User.findOne({ "personal_info.email": email }).select(
        "personal_info.fullname personal_info.username personal_info.profile_img google_auth"
      );
    } catch (err) {
      console.error(err);
      return res.status(500).json({ error: "Database error" });
    }

    // N·∫øu user ƒë√£ t·ªìn t·∫°i
    if (user) {
      if (!user.google_auth) {
        return res.status(403).json({
          error:
            "This email was signed up without Google. Please log in with a password to access the account.",
        });
      }
    } else {
      // N·∫øu ch∆∞a t·ªìn t·∫°i, t·∫°o user m·ªõi
      const username = await generateUsername(email);

      user = new User({
        personal_info: {
          fullname: name,
          email,
          username,
        },
        google_auth: true,
      });

      try {
        user = await user.save();
      } catch (err) {
        return res.status(500).json({ error: err.message });
      }
    }

    return res.status(200).json(formatDataSend(user));
  } catch (err) {
    return res.status(500).json({ error: err.message });
  }
});

// ==============================================================================
server.get("/get-upload-url", async (req, res) => {
  try {
    const uploadData = generateUploadURL();

    return res.status(200).json(uploadData);
  } catch (error) {
    console.log(error.message);
    return res.status(500).json({ error: error.message });
  }
});

//======================================================================================
// middleware verifyJWT
server.post("/create-blog", verifyJWT, async (req, res) => {
  let authorId = req.user;

  let { title, des, banner, tags, content, draft } = req.body;

  // ================= Validation ===================

  if (!title.length) {
    return res
      .status(403)
      .json({ error: "You must provide a title" });
  }

  if (!draft) {

    if (!des.length || des.length > 200) {
      return res.status(403).json({
        error: "You must provide blog description under 200 characters",
      });
    }

    if (!banner.length) {
      return res
        .status(403)
        .json({ error: "You must provide blog banner to publish it" });
    }

    if (!content.blocks.length) {
      return res
        .status(403)
        .json({ error: "There must be some blog content to publish it" });
    }

    if (!tags.length || tags.length > 10) {
      return res
        .status(403)
        .json({
          error: "Provide tags in order to publish the blog, Maximum 10",
        });
    }
  }

  // ================== X·ª≠ l√Ω ===================

  // Chuy·ªÉn t·∫•t c·∫£ tag th√†nh ch·ªØ th∆∞·ªùng ƒë·ªÉ ƒë·ªìng nh·∫•t.
  tags = tags.map((tag) => tag.toLowerCase());

  /*
    T·∫°o blog_id duy nh·∫•t:
    1.Thay m·ªçi k√Ω t·ª± kh√¥ng ph·∫£i ch·ªØ c√°i hay s·ªë th√†nh kho·∫£ng tr·∫Øng.
    2.Chuy·ªÉn m·ªçi kho·∫£ng tr·∫Øng (k·ªÉ c·∫£ nhi·ªÅu kho·∫£ng tr·∫Øng li√™n t·ª•c) th√†nh d·∫•u g·∫°ch ngang -
    3. Xo√° kho·∫£ng tr·∫Øng th·ª´a ·ªü ƒë·∫ßu v√† cu·ªëi chu·ªói.
    Th√™m chu·ªói ng·∫´u nhi√™n (nanoid) ƒë·ªÉ ƒë·∫£m b·∫£o uniqueness.

    let blog_id =
      title
        .replace(/[^a-zA-Z0-9]/g, " ")
        .replace(/\s+/g, "-")
        .trim() + nanoid();
  */

  let blog_id = slugify(title);

  let blog = new Blog({
    title,
    banner,
    des,
    tags,
    content,
    blog_id,
    author: authorId,
    draft: Boolean(draft),
  });

  /*
    N·∫øu l√† b·∫£n nh√°p (draft), kh√¥ng tƒÉng s·ªë l∆∞·ª£ng b√†i vi·∫øt. N·∫øu l√† b√†i th·∫≠t, tƒÉng 1 v√†o account_info.total_posts.
    
    $inc v√† $push l√† to√°n t·ª≠ (operator) m·∫∑c ƒë·ªãnh c·ªßa MongoDB
    $inc	Increment (TƒÉng s·ªë)	TƒÉng gi√° tr·ªã m·ªôt field ki·ªÉu s·ªë l√™n m·ªôt l∆∞·ª£ng nh·∫•t ƒë·ªãnh
    $push	Push v√†o m·∫£ng	Th√™m m·ªôt ph·∫ßn t·ª≠ v√†o m·∫£ng hi·ªán c√≥ trong document
  */
  try {
    const savedBlog = await blog.save();

    const incrementValue = draft ? 0 : 1;

    try {
      await User.findOneAndUpdate(
        { _id: authorId },
        {
          $inc: { "account_info.total_posts": incrementValue },
          $push: { blogs: savedBlog._id },
        }
      );
    } catch (err) {
      return res
        .status(500)
        .json({ error: "Failed to update total posts number" });
    }

    return res.status(200).json({ id: savedBlog.blog_id });
  } catch (err) {
    return res.status(500).json({ error: "Failed to create blog" });
  }
});

// =======================================================================================
server.listen(PORT, () => {
  console.log(`üöÄ Server is running on port ${PORT}.`);
});
